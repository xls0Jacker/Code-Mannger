图论相关知识点：

1.基本知识点：
    1.0 顶点的集合为V，边的集合为E的图记为G=(V,E)
        连接两点u和v的边记作e=(u,v)

    1.1 图大体分为两种--有向图和无向图
        其边带有权值的叫带权图

    1.2 在无向图中：
        相邻--两个顶点之间有边连接
        路径--相邻顶点的序列
        圈--起点和终点重合的路径
        连通图--任意两点之间都有路径连接
        树--没有圈的连通图（边数=顶点数-1）
        森林--没有圈的非连通图（边数=顶点数-1）

    1.3 在有向图中：
        ∂+(v)--以有向图顶点v为起点的边的集合
        ∂-(v)--以有向图顶点v为终点的边的集合
        |∂+(v)|--出度
        |∂-(v)|--入度
        DAG--没有圈的有向图（可使用拓扑排序-->可使用DP）

2.图的表示：（记顶点和边的集合为V，E；顶点和边的个数为|V|，|E|）
    2.1 邻接矩阵:
        使用|V|*|V|的二维数组保存图；
        花费O(|V|^2)的空间（因此在边很少的稀疏图中十分浪费）
        此外，对于带权图若存在自环或是重边的情况下，
        一般保证权值最大（最小）的边即可，
        若要保所有的边，建议使用邻接表
        在无向图中：
            若顶点i与顶点j间有边相连，那么就设g[i][j]=g[j][i]=1，否则设为0
        在有向图中：
            若顶点i有一条指向j的边，那么就设g[i][j]=1，否则设为0
        在带权图中：
            初始设g[i][j]为INF
            在有向图和无向图中照旧
            对于在一条边上有多个不同权值的情况，定义多个同样的|V|*|V|的数组，
            或者使用结构体或类作为数组的元素，就可以和原来的图一样处理了

    2.2 邻接表：
        花费O(|V|+|E|)的空间

3.最短路问题：
    3.1 单源最短路问题：
        Bellman-Ford算法：
            时间复杂度为O(|V|*|E|)
            可求单元最短路，判断负圈
            无局限性
        Dijkstra算法：
            时间复杂度为O(|V|^2)
            可求单源最短路
            在图中存在负权时不适用
        Dijkstra算法堆优化：
            时间复杂度降为O(|E|log|V|)
            其余不变

    3.2 任意两点间的最短路问题：
        Floyd-Warshall算法：
            时间复杂度为O(|V|^3)
            可求任意两点间的最短路径，判断负圈
            无局限性

    3.3 路径还原：
        使用prev[j]来记录顶点j的前驱
        时间复杂度O(|V|)
        通过d[j]=d[k]+cost[k][j]关系式，
        更新prev[j]=k，
        最后逆向输出即可得到路径
        
4.最小生成树：
    生成树--给出一个图，它的某个子图中的任意两个顶点都相互连通并且时一棵树
    最小生成树--边上有权值，使得边权和最小的生成树
    Prim算法：
        时间复杂度为O(|V|^2)
    Prim算法堆优化：
        时间复杂度降为O(|E|log|V|)
    Kruskal算法:
        时间复杂度为O(|E|log|V|)
        需先完成并查集
